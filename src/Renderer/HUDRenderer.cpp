#include "HUDRenderer.h"
#include "Core/Logger.h"
#include "Renderer/Buffer.h"
#include <cstring>
#include <glad/glad.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <iomanip>
#include <sstream>

namespace S67 {

// 8x8 Bitmap Font Data (Basic ASCII 32-127)
static const unsigned char s_Font8x8[96][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // (space)
    {0x18, 0x3c, 0x3c, 0x18, 0x18, 0x00, 0x18, 0x00}, // !
    {0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // "
    {0x36, 0x36, 0x7f, 0x36, 0x7f, 0x36, 0x36, 0x00}, // #
    {0x18, 0x3e, 0x60, 0x3c, 0x06, 0x7c, 0x18, 0x00}, // $
    {0x00, 0x66, 0x66, 0x0c, 0x18, 0x33, 0x33, 0x00}, // %
    {0x38, 0x6c, 0x38, 0x76, 0x6c, 0x6c, 0x3a, 0x00}, // &
    {0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00}, // '
    {0x0c, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x00}, // (
    {0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x18, 0x30, 0x00}, // )
    {0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00}, // *
    {0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00}, // +
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30}, // ,
    {0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00}, // -
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00}, // .
    {0x02, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x40, 0x00}, // /
    {0x3c, 0x66, 0x6e, 0x7e, 0x76, 0x66, 0x3c, 0x00}, // 0
    {0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00}, // 1
    {0x3c, 0x66, 0x06, 0x0c, 0x18, 0x30, 0x7e, 0x00}, // 2
    {0x3c, 0x66, 0x06, 0x1c, 0x06, 0x66, 0x3c, 0x00}, // 3
    {0x06, 0x0e, 0x1e, 0x36, 0x7f, 0x06, 0x06, 0x00}, // 4
    {0x7e, 0x60, 0x7c, 0x06, 0x06, 0x66, 0x3c, 0x00}, // 5
    {0x1c, 0x30, 0x60, 0x7c, 0x66, 0x66, 0x3c, 0x00}, // 6
    {0x7e, 0x06, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00}, // 7
    {0x3c, 0x66, 0x66, 0x3c, 0x66, 0x66, 0x3c, 0x00}, // 8
    {0x3c, 0x66, 0x66, 0x3e, 0x06, 0x0c, 0x38, 0x00}, // 9
    {0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00}, // :
    {0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30, 0x00}, // ;
    {0x00, 0x0c, 0x18, 0x30, 0x18, 0x0c, 0x00, 0x00}, // <
    {0x00, 0x00, 0x7e, 0x00, 0x7e, 0x00, 0x00, 0x00}, // =
    {0x00, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x00, 0x00}, // >
    {0x3c, 0x66, 0x06, 0x0c, 0x18, 0x00, 0x18, 0x00}, // ?
    {0x3c, 0x66, 0x6e, 0x6e, 0x60, 0x30, 0x1e, 0x00}, // @
    {0x18, 0x3c, 0x66, 0x66, 0x7e, 0x66, 0x66, 0x00}, // A
    {0x7c, 0x66, 0x66, 0x7c, 0x66, 0x66, 0x7c, 0x00}, // B
    {0x3c, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3c, 0x00}, // C
    {0x78, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0x78, 0x00}, // D
    {0x7e, 0x60, 0x60, 0x78, 0x60, 0x60, 0x7e, 0x00}, // E
    {0x7e, 0x60, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00}, // F
    {0x3c, 0x66, 0x60, 0x6e, 0x66, 0x66, 0x3c, 0x00}, // G
    {0x66, 0x66, 0x66, 0x7e, 0x66, 0x66, 0x66, 0x00}, // H
    {0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00}, // I
    {0x06, 0x06, 0x06, 0x06, 0x06, 0x66, 0x3c, 0x00}, // J
    {0x66, 0x6c, 0x78, 0x70, 0x78, 0x6c, 0x66, 0x00}, // K
    {0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7e, 0x00}, // L
    {0x63, 0x77, 0x7f, 0x7f, 0x6b, 0x63, 0x63, 0x00}, // M
    {0x66, 0x76, 0x7e, 0x7e, 0x7e, 0x6e, 0x66, 0x00}, // N
    {0x3c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00}, // O
    {0x7c, 0x66, 0x66, 0x7c, 0x60, 0x60, 0x60, 0x00}, // P
    {0x3c, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x0e, 0x00}, // Q
    {0x7c, 0x66, 0x66, 0x7c, 0x78, 0x6c, 0x66, 0x00}, // R
    {0x3c, 0x66, 0x30, 0x18, 0x0c, 0x66, 0x3c, 0x00}, // S
    {0x7e, 0x5a, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00}, // T
    {0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00}, // U
    {0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00}, // V
    {0x63, 0x63, 0x63, 0x6b, 0x7f, 0x7f, 0x63, 0x00}, // W
    {0x66, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0x66, 0x00}, // X
    {0x66, 0x66, 0x66, 0x3c, 0x18, 0x18, 0x18, 0x00}, // Y
    {0x7e, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x7e, 0x00}, // Z
    {0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00}, // [
    {0x40, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00}, // \ (backslash)
    {0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00}, // ]
    {0x18, 0x3c, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00}, // ^
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00}, // _
    {0x30, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00}, // `
    {0x00, 0x00, 0x3c, 0x06, 0x3e, 0x66, 0x3e, 0x00}, // a
    {0x60, 0x60, 0x7c, 0x66, 0x66, 0x66, 0x7c, 0x00}, // b
    {0x00, 0x00, 0x3c, 0x60, 0x60, 0x66, 0x3c, 0x00}, // c
    {0x06, 0x06, 0x3e, 0x66, 0x66, 0x66, 0x3e, 0x00}, // d
    {0x00, 0x00, 0x3c, 0x66, 0x7e, 0x60, 0x3c, 0x00}, // e
    {0x1c, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x00}, // f
    {0x00, 0x00, 0x3e, 0x66, 0x66, 0x3e, 0x06, 0x3c}, // g
    {0x60, 0x60, 0x7c, 0x66, 0x66, 0x66, 0x66, 0x00}, // h
    {0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3c, 0x00}, // i
    {0x06, 0x00, 0x06, 0x06, 0x06, 0x06, 0x06, 0x3c}, // j
    {0x60, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0x00}, // k
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x1c, 0x00}, // l
    {0x00, 0x00, 0x66, 0x7f, 0x7f, 0x6b, 0x63, 0x00}, // m
    {0x00, 0x00, 0x7c, 0x66, 0x66, 0x66, 0x66, 0x00}, // n
    {0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x3c, 0x00}, // o
    {0x00, 0x00, 0x7c, 0x66, 0x66, 0x7c, 0x60, 0x60}, // p
    {0x00, 0x00, 0x3e, 0x66, 0x66, 0x3e, 0x06, 0x06}, // q
    {0x00, 0x00, 0x7c, 0x66, 0x60, 0x60, 0x60, 0x00}, // r
    {0x00, 0x00, 0x3e, 0x60, 0x3c, 0x06, 0x7c, 0x00}, // s
    {0x30, 0x30, 0x78, 0x30, 0x30, 0x30, 0x1c, 0x00}, // t
    {0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3e, 0x00}, // u
    {0x00, 0x00, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00}, // v
    {0x00, 0x00, 0x63, 0x6b, 0x7f, 0x7f, 0x63, 0x00}, // w
    {0x00, 0x00, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0x00}, // x
    {0x00, 0x00, 0x66, 0x66, 0x66, 0x3e, 0x06, 0x3c}, // y
    {0x00, 0x00, 0x7e, 0x0c, 0x18, 0x30, 0x7e, 0x00}, // z
    {0x0c, 0x18, 0x18, 0x30, 0x18, 0x18, 0x0c, 0x00}, // {
    {0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00}, // |
    {0x30, 0x18, 0x18, 0x0c, 0x18, 0x18, 0x30, 0x00}, // }
    {0x00, 0x00, 0x3b, 0x6e, 0x00, 0x00, 0x00, 0x00}, // ~
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}  // 127
};

HUDRenderer::HUDData *HUDRenderer::s_Data = nullptr;

void HUDRenderer::Init() {
  s_Data = new HUDData();

  // Create quad vertex array for rendering UI elements
  // 2D quad: position (x, y) + texcoord (u, v)
  float quadVertices[] = {
      // positions    // texcoords
      0.0f, 0.0f, 0.0f, 0.0f, // bottom-left
      1.0f, 0.0f, 1.0f, 0.0f, // bottom-right
      1.0f, 1.0f, 1.0f, 1.0f, // top-right
      0.0f, 1.0f, 0.0f, 1.0f  // top-left
  };

  uint32_t quadIndices[] = {
      0, 1, 2, // first triangle
      2, 3, 0  // second triangle
  };

  s_Data->QuadVAO = VertexArray::Create();

  Ref<VertexBuffer> quadVBO =
      VertexBuffer::Create(quadVertices, sizeof(quadVertices));
  quadVBO->SetLayout({{ShaderDataType::Float2, "a_Position"},
                      {ShaderDataType::Float2, "a_TexCoord"}});
  s_Data->QuadVAO->AddVertexBuffer(quadVBO);

  Ref<IndexBuffer> quadIBO =
      IndexBuffer::Create(quadIndices, sizeof(quadIndices) / sizeof(uint32_t));
  s_Data->QuadVAO->SetIndexBuffer(quadIBO);

  // Create Font Texture Atlas (12 characters wide, 8 characters high = 96
  // characters) Each character is 8x8 pixels. Total texture size: 96x8 pixels
  // in a strip. Actually let's make it 128x64 for alignment reasons.
  uint32_t atlasWidth = 128;
  uint32_t atlasHeight = 64;
  unsigned char *atlasPixels = new unsigned char[atlasWidth * atlasHeight];
  memset(atlasPixels, 0, atlasWidth * atlasHeight);

  for (int i = 0; i < 96; i++) {
    int charX = (i % 16) * 8;
    int charY = (i / 16) * 8;
    for (int y = 0; y < 8; y++) {
      for (int x = 0; x < 8; x++) {
        if (s_Font8x8[i][y] & (1 << (7 - x))) {
          // Flip Y: atlasPixels expects bottom-to-top, but source data is
          // top-to-bottom
          atlasPixels[(charY + (7 - y)) * atlasWidth + (charX + x)] = 255;
        }
      }
    }
  }

  glGenTextures(1, &s_Data->FontTextureID);
  glBindTexture(GL_TEXTURE_2D, s_Data->FontTextureID);
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RED, atlasWidth, atlasHeight, 0, GL_RED,
               GL_UNSIGNED_BYTE, atlasPixels);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

  delete[] atlasPixels;

  S67_CORE_INFO("HUDRenderer initialized with 8x8 bitmap font");
}

void HUDRenderer::SetShader(const Ref<Shader> &shader) {
  if (s_Data) {
    s_Data->HUDShader = shader;
  }
}

void HUDRenderer::Shutdown() {
  if (s_Data) {
    if (s_Data->FontTextureID)
      glDeleteTextures(1, &s_Data->FontTextureID);
    delete s_Data;
    s_Data = nullptr;
  }
  S67_CORE_INFO("HUDRenderer shutdown");
}

void HUDRenderer::BeginHUD(float width, float height) {
  if (!s_Data)
    return;

  s_Data->ViewportWidth = width;
  s_Data->ViewportHeight = height;

  s_Data->ProjectionMatrix = glm::ortho(0.0f, width, 0.0f, height, -1.0f, 1.0f);

  glDisable(GL_DEPTH_TEST);
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
}

void HUDRenderer::EndHUD() { glEnable(GL_DEPTH_TEST); }

void HUDRenderer::RenderCrosshair() {
  if (!s_Data || !s_Data->HUDShader || !s_Data->HUDShader->IsValid())
    return;

  float centerX = s_Data->ViewportWidth / 2.0f;
  float centerY = s_Data->ViewportHeight / 2.0f;

  float lineLength = 20.0f;
  float lineThickness = 2.0f;
  float gap = 4.0f;

  glm::vec4 crosshairColor = glm::vec4(1.0f, 1.0f, 1.0f, 0.8f);

  RenderQuad(
      glm::vec2(centerX - lineLength - gap, centerY - lineThickness / 2.0f),
      glm::vec2(lineLength, lineThickness), crosshairColor);
  RenderQuad(glm::vec2(centerX + gap, centerY - lineThickness / 2.0f),
             glm::vec2(lineLength, lineThickness), crosshairColor);
  RenderQuad(glm::vec2(centerX - lineThickness / 2.0f, centerY + gap),
             glm::vec2(lineThickness, lineLength), crosshairColor);
  RenderQuad(
      glm::vec2(centerX - lineThickness / 2.0f, centerY - lineLength - gap),
      glm::vec2(lineThickness, lineLength), crosshairColor);
}

void HUDRenderer::RenderSpeed(float speed) {
  if (!s_Data)
    return;

  // Format: [speed] u/s using stringstream
  std::stringstream ss;
  ss << std::fixed << std::setprecision(0) << "[" << (int)std::round(speed)
     << "] u/s";
  std::string speedText = ss.str();

  float scale = 2.5f; // Scale factor for the font
  float charWidth = 8.0f * scale;
  float textWidth = speedText.length() * charWidth;

  // Bottom center
  glm::vec2 position = {(s_Data->ViewportWidth - textWidth) * 0.5f, 40.0f};

  // Slightly orange color (Source engine style)
  glm::vec4 orange = glm::vec4(1.0f, 0.7f, 0.0f, 0.9f);

  DrawString(speedText, position, scale, orange);
}

void HUDRenderer::DrawString(const std::string &text, const glm::vec2 &position,
                             float scale, const glm::vec4 &color) {
  if (!s_Data || !s_Data->HUDShader || !s_Data->FontTextureID)
    return;

  s_Data->HUDShader->Bind();
  s_Data->HUDShader->SetMat4("u_Projection", s_Data->ProjectionMatrix);
  s_Data->HUDShader->SetFloat4("u_Color", color);
  s_Data->HUDShader->SetInt("u_UseTexture", 1);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, s_Data->FontTextureID);
  s_Data->HUDShader->SetInt("u_Texture", 0);

  glm::vec2 currentPos = position;
  float charSize = 8.0f * scale;

  for (char c : text) {
    if (c < 32 || c > 127)
      continue;

    int index = c - 32;
    int charX = (index % 16);
    int charY = (index / 16);

    // UV coordinates in the atlas
    float uStart = (charX * 8.0f) / 128.0f;
    float vStart = (charY * 8.0f) / 64.0f;
    float uEnd = uStart + (8.0f / 128.0f);
    float vEnd = vStart + (8.0f / 64.0f);

    // Using a custom transform matrix for each character
    glm::mat4 transform =
        glm::translate(glm::mat4(1.0f), glm::vec3(currentPos, 0.0f));
    transform = glm::scale(transform, glm::vec3(charSize, charSize, 1.0f));
    s_Data->HUDShader->SetMat4("u_Transform", transform);

    // We need to update the UVs in the shader or use a separate VAO per
    // character. For simplicity with the existing RenderQuad which assumes
    // static UVs, let's just use a special RenderQuadInternal that takes UVs.

    // Actually, I'll update the global QuadVAO's UVs or better:
    // pass UVs as uniforms.
    s_Data->HUDShader->SetFloat4("u_UVBounds",
                                 glm::vec4(uStart, vStart, uEnd, vEnd));

    s_Data->QuadVAO->Bind();
    glDrawElements(GL_TRIANGLES, s_Data->QuadVAO->GetIndexBuffer()->GetCount(),
                   GL_UNSIGNED_INT, nullptr);

    currentPos.x += charSize;
  }

  s_Data->HUDShader->SetInt("u_UseTexture", 0);
}

void HUDRenderer::RenderQuad(const glm::vec2 &position, const glm::vec2 &size,
                             const glm::vec4 &color, uint32_t textureID) {
  if (!s_Data || !s_Data->HUDShader || !s_Data->QuadVAO)
    return;

  glm::mat4 transform =
      glm::translate(glm::mat4(1.0f), glm::vec3(position, 0.0f));
  transform = glm::scale(transform, glm::vec3(size, 1.0f));

  s_Data->HUDShader->Bind();
  s_Data->HUDShader->SetMat4("u_Projection", s_Data->ProjectionMatrix);
  s_Data->HUDShader->SetMat4("u_Transform", transform);
  s_Data->HUDShader->SetFloat4("u_Color", color);

  if (textureID != 0) {
    s_Data->HUDShader->SetInt("u_UseTexture", 1);
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, textureID);
    s_Data->HUDShader->SetInt("u_Texture", 0);
    s_Data->HUDShader->SetFloat4("u_UVBounds",
                                 glm::vec4(0.0f, 0.0f, 1.0f, 1.0f));
  } else {
    s_Data->HUDShader->SetInt("u_UseTexture", 0);
  }

  s_Data->QuadVAO->Bind();
  glDrawElements(GL_TRIANGLES, s_Data->QuadVAO->GetIndexBuffer()->GetCount(),
                 GL_UNSIGNED_INT, nullptr);
}

} // namespace S67
